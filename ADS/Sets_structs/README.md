# 1. Цель лабораторной работы
Исследование четырех способов хранения множеств в памяти ЭВМ.
# 2. Задание для лабораторной работы
Разработать программу, которая выполняет вычисление конечного множества Е, содержащее все цифры, общие для A и B, а также все цифры, являющиеся общими для C и D. Универсум: шестнадцатеричные цифры.
# 3. Формализация задания
E=(A&B)|(C&D)
# 4. Контрольныетесты
Тестирование программы реализовано через юнит-тесты для функций объединения и пересечения множеств в структуре vector поотдельности. Юнит-тесты находятся в отдельном файле tests.cpp и их объявление в файле tests.h. 
Тестирование вызывается функцией test_vec_func(); в самом начале функции main.

При прохождении всех тестов, в консоль выводится сообщение "Vector functions: OK", в противном случае выводится сообщение об ошибке и указанием функции, которая не прошла тесты.

Тестирование производится на базовых наборах данных для тестов:
а) пустыемножества;
б) множества,содержащиетолько0;
в) одинаковыемножества;
г) множестванесодержатодинаковыхэлементов;
д) содинаковымпервым/последнимэлементом;
е) одинаковыйэлементпосередине;
ж)одноизмножеств–пустое;
з) мощностьпервогомножествабольше
и) мощностьвторогомножествабольше.
# 5. Временнаясложность
Для оптимизации работы программы все исходные данные сортируются алгоритмом быстрой сортировки, временная сложность которой O(n*log(n)). Это позволяет сравнивать две структуры данных с помощью метода двух указателейзавремяO(n).
Следовательно:
а) Временная сложность для представления множеств в виде структуры vector: O(n*log(n)).
б) Временная сложность для представления множеств в виде структуры list: O(n*log(n)).

Работа с массивами битов не требует предварительной сортировки массива, так как элементы множества являются индексами массива битов. Поэтому, временная сложность здесь будет: O(n) в общем случае.

Работа с машинными словами так же требует предварительной сортировки за O(n*log(n)), но вместо метода двух указателей здесь применены побитовые операции, работающие за время O(1).
Следовательно: Временная сложность для представления множеств в виде машинного: O(n*log(n)), но работает быстрее первых двух так как побитовые операции работают быстрее.
# 6. Выводы
Основываясь на данных, полученных в пункте 6, что самым быстрым способом работы с множествами является способ представления в массиве битов. Для большей оптимизации предлагается размещать данные из массивов битов в регистры AX, BX, CX и DX и пользоваться инструкциями AND и OR.

Машинные слова также хороший способ работы со множествами, поскольку поразрядные операции выполняются намного быстрее,чем операции сложения,которые есть в других вариантах реализаций, а код метода работы с машинными словами занимает намного меньше места.

Метод размещения множеств в списках показал худшее время обработки. Это связано с тем, что в стандартной реализации list в С++ не определена операция обращения к элементу по индексу или функция at(), что вынуждает использовать функции удаления элементов списка в ходе выполнения вычислений. Это значительно замедляет работу алгоритма.
# 7. Список использованных источников
1) Колинько П.Г. Алгоритмы и структуры данных. Часть1: Пособие к самостоятельной работе и курсовому проектированию. Вып. 2001 (для заочников).–СПб.,2020.– 71 с.
2) Быстрая сортировка:
```
http://cppstudio.com/post/891/?ysclid=lj8e3kdw6z
```
