# 1. Цель лабораторной работы
Исследование алгоритмов для работы с троичным деревом.
# 2. Задание для лабораторной работы
Разработать программу, которая реализует алгоритм обхода троичного дерева слева направо и считает количество вершин не на самом нижнем уровне.
# 3. Обоснование выбора способа представления деревьев в памяти
В качестве способа хранения дерева в памяти используются нелинейные списки, каждый элемент которого имеет указатели на родителя и на трех своих потомков, а также переменную с данными. Этот способ является оптимальным способом хранения в памяти дерева, для текущего задания. Обуславливается это тем, что дерево генерируется автоматически, и найти шаблон, который бы подходил к каждой случайной генерации – невозможно. А хранить дерево в виде матриц смежности и инцидентности неэффективно с точки зрения занимаемой памяти, т.к. не гарантируется, что у каждого узла будет 3 потомка.
# 4. Оценки временной сложности функций
а) Метод tree_gen(Node*,char): O(N);
б) Метод set_screen(Node*,int,int): O(N);
в) Метод print(): O(1);
г) Метод get_data(): O(1).
# 5. Выводы
Реализованный алгоритм обхода дерева (слева направо) – устоявшийся способ работы с деревьями наравне и с другими рекурсивными алгоритмами: прямым и обратным. Внутренний обход часто применяется для отсортированных бинарных деревьев, т.к. обрабатывает значения в порядке возрастания.
# 6. Список использованных источников
1) Колинько П.Г. Алгоритмы и структуры данных. Часть1: Пособие к самостоятельной работе и курсовому проектированию. Вып. 2001 (для заочников).–СПб.,2020.– 71 с.
2) Быстрая сортировка:
```
http://cppstudio.com/post/891/?ysclid=lj8e3kdw6z
```
